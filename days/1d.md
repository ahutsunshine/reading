## 作者为什么写这本书

对于架构模式，我们有听过领域架构(Domain Architecture)，六边形架构(Hexagonal Architecture)等，里面的概念很多， 大多也很抽象， 缺乏具体实例和实践让我们感觉身受。
作者希望写这本书提供一个具体的web程序实例来实现六边形结构，里面做许多概念做了详细的解释和代码标示，希望这些概念和实践可以为读者实际软件设计带来指导， 成为他们的工具，而不是一种负担。

## 分层架构(Layer Architecture)

### 为什么分层

如果一个系统不采用分层架构可不可以？答案当然是可以的。软件的开发是有迭代的，并不是一步到位的，处于不同的阶段就会有不同的需求，这些需求就逼迫着你不断调整架构设计。
当软件处于初期时，可能没有什么业务逻辑，没有什么用户量，而软件最主要的目标就是快速上线，实践商业模式。此时，可以不考虑分层。但随着业务逻辑的复杂，业务板块的增多，彼此之间就会出现错综复杂的依赖关系，随之就会产生的逻辑不清晰、可读性差，维护困难，改动一处动全身等问题。
这个时候就需要对软件结构关注分离，分工合作，分离的层只关注自己的角色，解耦合提高开发效率。

### 分层结构

传统经典的分层结构如下:

1. 表示层(Presentation Layer)/前端(Web Layer): 展现给用户的界面
2. 业务层(Business Layer)/领域层(Domain Layer): 负责系统业务逻辑的处理
3. 持久层(Persistence Layer):层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等

表示层 -> 业务层 -> 持久层 -> 数据库

### 表示层为何不能直接访问数据库，这样不是更快吗?

也许我们会有疑惑，为什么表示层不能直接访问数据库，而是通过持久层统一访问呢？这样做的原因是层次隔离(layers of isolation)。

- 层次的隔离意味着每个层独立于其他层，不需要知道其他层的内部工作机理, 降低耦合和逻辑。
- 层次隔离意味着架构中一个层的改变不会影响其他层的组件，如果允许表示层直接访问数据库，那么持久层中对SQL的改变可能会直接影响表示层。同理，表示层对数据库的操作也可能影响持久层的逻辑，因此会产生一个组件相互依赖的耦合紧密的应用。

### 分层的依据与原则

1. 分层的第一个依据是基于关注点为不同的调用目的划分层次。

   我们之所以要以水平方式对整个系统进行分层，是我们下意识地确定了一个认知规则：机器为本，用户至上。分层架构中的层次越往上越面向业务，面向用户；层次越往下，越通用，面向设备。
   为什么经典分层架构为三层架构？正是源于这样的认知规则：其上，面向用户的体验与交互；其中，面向应用与业务逻辑；其下，面对各种外部资源与设备。

2. 分层的第二个依据是面对变化

   分层时应针对不同的变化原因确定层次的边界，严禁层次之间互相干扰，或者至少将变化对各层带来的影响降到最低。
   层与层之间的关系应该是正交的。所谓“正交”，并非二者之间没有关系，而是垂直相交的两条直线。唯一相关的依赖点是这两条直线的相交点，即两层之间的协作点。
   正交的两条直线，无论哪条直线进行延伸，都不会对另一条直线产生任何影响（指直线的投影）。如果非正交，即“斜交”，当一条直线延伸时，它总是会投影到另一条直线，这就意味着另一条直线会受到它变化的影响。

### 分层优缺点

**优点:**

1. 可以降低层与层之间的依赖
2. 分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。
3. 分层之后可以做到很高的复用。比如，我们在设计系统 A 的时候，发现某一层具有一定的通用性，那么我们可以把它抽取独立出来，在设计系统 B 的时候使用起来，这样可以减少研发周期，提升研发的效率。
4. 分层架构可以让我们更容易做横向扩展。如果系统没有分层，当流量增加时我们需要针对整体系统来做扩展。但是，如果我们按照上面提到的三层架构将系统分层后，就可以针对具体的问题来做细致的扩展。 比如说，业务逻辑里面包含有比较复杂的计算，导致
   CPU 成为性能的瓶颈，那这样就可以把逻辑层单独抽取出来独立部署，然后只对逻辑层来做扩展，这相比于针对整体系统扩展所付出的代价就要小的多了。

缺点:

1. 增加了代码的复杂度，有时会导致级联的修改: 有些业务可以在接收到请求后就可以直接查询数据库获得结果，却偏偏要在中间插入多个层次，并且有可能每个层次只是简单地做数据的传递。
   有时增加一个小小的需求也需要更改所有层次上的代码，看起来增加了开发的成本，并且从调试上来看也增加了复杂度。
2. 降低了系统的性能: 如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。

那我们是否要选择分层的架构呢？答案当然是肯定的。

你要知道，任何的方案架构都是有优势有缺陷的。分层架构固然会增加系统复杂度，也可能会有性能的损耗，但是相比于它能带给我们的好处来说，这些都是可以接受的， 或者可以通过其它的方案解决的。我们在做决策的时候切不可以偏概全，因噎废食。

## 层之间的协作(非常重要！！！)

在我们固有的认识中，分层架构的依赖都是自顶向下传递的，这也符合大多数人对分层的认知模型。从抽象层次看，层次越处于下端，就会变得越通用越公共，与具体的业务隔离得越远。出于重用的考虑，这些通用和公共的功能往往会被单独剥离出来形成平台或框架，在系统边界内的低层，除了面向高层提供足够的实现外，就都成了平台或框架的调用者。换言之，越是通用的层，越有可能与外部平台或框架形成强依赖。若依赖的传递方向仍然采用自顶向下，就会导致系统的业务对象也随之依赖于外部平台或框架。

依赖反转原则（Dependency Inversion
Principle，DIP）提出了对这种自顶向下依赖的挑战，它要求“高层模块不应该依赖于低层模块，二者都应该依赖于抽象。”这个原则正本清源，给了我们当头棒喝——谁规定在分层架构中，依赖就一定要沿着自顶向下的方向传递？我们常常理解依赖，是因为被依赖方需要为依赖方（调用方）提供功能支撑，这是从功能重用的角度来考虑的。但我们不能忽略变化对系统产生的影响！与建造房屋一样，我们自然希望分层的模块“构建”在稳定的模块之上。谁更稳定？抽象更稳定。因此，依赖反转原则隐含的本质是：我们要依赖不变或稳定的元素（类、模块或层）。也就是该原则的第二句话：抽象不应该依赖于细节，细节应该依赖于抽象。

这一原则实际是“面向接口设计”原则的体现，即“针对接口编程，而不是针对实现编程”。高层模块对低层模块的实现是一无所知的，带来的好处是：

低层模块的细节实现可以独立变化，避免变化对高层模块产生污染 在编译时，高层模块可以独立于低层模块单独存在 对于高层模块而言，低层模块的实现是可替换的
倘若高层依赖于低层的抽象，必然会面对一个问题：如何将具体的实现传递给高层的类？由于在高层通过接口隔离了对具体实现的依赖，就意味着这个具体依赖被转移到了外部，究竟使用哪一种具体实现，由外部的调用者来决定。只有在运行调用者代码时，才将外面的依赖传递给高层的类。Martin
Fowler 形象地将这种机制称为“依赖注入（dependency injection）”。

**为了更好地解除高层对低层的依赖，我们往往需要将依赖反转原则与依赖注入结合起来。**

------- 后续更新例子

## TODO

- 了解领域架构
- 了解六边形架构
